#!/bin/bash
# aurpac - Light'n'fast aur and pacman frontend.
# Localize (gettext)
TEXTDOMAIN=aurpac
# TODO: $makedir cleaner
# TODO: Poprawna interpretacja nierówności w depends i porównywanie.. 
#       (narazie poprawnie odczytuje nazwę ale nie umie porównać wersji) (3/10)
# TODO: Log: install & depends; upgrade 0/10
# TODO: Pacman integration.. 4/10
# TODO: Coloring pacman output without pacman-color 0/10

IgnorePKG=("cedega")

[ -z "$PREFIX" ] && \
PREFIX="/usr" ###SED###

cols="$(tput cols)"

# Config loader
for i in "$PREFIX/../etc/aurpac.conf" "$HOME/.aurpac.conf"; do
	[ -r "$i" ] && . $i
done
unset i

mod_load() {
# First modular mechanism ;)
	if [ ! -z "$1" ] && [ -d "$PREFIX/share/aurpac/mod/$1/" ]; then
		local i ii mod="$1"
		shift
		if [ -z "$2" ]; then
			for i in $PREFIX/share/aurpac/mod/$mod/*; do
				. $i
			done
		else
			for i in $@; do
				if [ "${i:0:1}" != '!' ]; then
					[ -e "$PREFIX/share/aurpac/mod/$mod/$i" ] && . $PREFIX/share/aurpac/mod/$mod/$i
				fi
			done
		fi
	fi
}

msg() {
# message..
	if [ -z "$2" ]; then
		printf "\e[0;%sm%s \e[0;%sm%s\e[0m\n" "$color_msg_arrow" \
			"${style_msg_arrow-==>}" "$color_msg_text" "$1"
	elif [ "$2" = "w" ]; then
		printf "\e[0;%sm%s \e[0;%sm%s\e[0m\n" "$color_warn_arrow" \
			"${style_warn_arrow-==>}" "$color_warn_text" "$1" >&2
	fi
}
ask() {
# ask dialog..
	local key yn=$"YyNn - Yes or No" rev=0
	if [ "$2" == "rev" ]; then rev=1; fi
	if [ "$NOCONFIRM" = "1" ]; then return $rev; fi
	printf "\e[0;%sm%s\e[0;%sm %s \e[0;%sm[%s]\e[0m " \
		"$color_ask_arrow" "$style_ask_arrow" "$color_ask_text" \
		"$1" "$color_ask_ans" "${yn:$[0+rev]:1}/${yn:$[3-rev]:1}"
	read key
	case ${key:0:1} in
		"${yn:$[2-rev-rev]:1}"|"${yn:$[3-rev-rev]:1}") return $[1-rev] ;;
		*) return $[0+rev] ;;
	esac
}
sep() {
	if [ -z "$SEP" ]; then
		local ch=${style_sep_char--}
		SEP="$(printf "%*s" "$cols")"
		SEP="$(printf '%s' "${SEP// /${ch:0:1}}")"
	fi
	printf "\e[0;%sm%s\e[0m\n" "$color_sep_char" "$SEP"
}
check_ver() {
	local oldver=0 newver evalver c cpkg="$1" i
	for i in ${IgnorePKG[*]}; do
		if [ "$i" = "$cpkg" ]; then return 0; fi
	done
	c="$(curl 'http://aur.archlinux.org/rpc.php?type=info&arg='"$cpkg" 2> /dev/null)"
	oldver="$($pacman -Q $cpkg 2> /dev/null|sed 's/'"$cpkg"' \(.*\)$/\1/g')"
	if [ "$(echo $c|grep -c 'type":"info')" = "1" -a -n "$oldver" ]; then
		newver="$(echo $c|sed -r 's/.*"[Vv]ersion":[ "]*([^",]*).*/\1/g')"
		if [ "$newver" != "$oldver" ]; then
			evalver="$(echo -e "$newver\n$oldver"|sort -r|sed '1q')"
			if [ "$evalver" == "$newver" ]; then
				printf "%s" "$cpkg-$newver "
				return 1
			fi
		fi
	fi
	return 0
}
updates_print() {
	local -i npkg=0
	local i
	# policz pakiety
	for i in $@; do let npkg++; done
	local ppkg target=$"Targets"" ($npkg): "
	local -i colslen=0 step=0 targetlen="${#target}"
	# formatowanie wyjścia na styl pacmana
	for ppkg in $@; do
		if (( $step == 0 )); then
			printf "\e[0;%sm%s\e[0m" "$color_targets" "$target"
			colslen="$targetlen"
			step=2
		fi
		if (( "$[colslen+${#ppkg}]" > "$cols" )); then
			step=1
		fi
		if (( $step == 1 )); then
			printf "\n\e[$[targetlen+1]G"
			colslen="$targetlen"
			step=2
		fi
		if (( $step == 2 )); then
			printf "$ppkg "
			colslen="$[colslen+${#ppkg}+1]"
		fi
	done
	printf "\n\n"
	(( $npkg > 0 )) && return 0 || return 1
}
tar_get() {
	c="$(curl 'http://aur.archlinux.org/rpc.php?type=info&arg='"$1" 2> /dev/null)"
	if [ "$(echo $c|grep -c 'type":"error')" = "1" ]; then
		return 1
	else
		if $pacman -Si $1 > /dev/null 2>&1; then
			return 2
		else
			printf "\e[0;%sm" "$color_progress"
			curl "$(echo $c|sed 's/\\\//\//g; s|.*URLPath":"\(.*\)","License.*|http://aur.archlinux.org\1|g')" -# |zcat > $tartmp
			printf "\e[0m"
			return 0
		fi
	fi
}
tar_del() {
	if [ -f "$tartmp" ]; then
		rm $tartmp
	fi
}
install_now() {
#	local -i err=0
	cd "$makedir/$1" || exit 1
	msg $"Starting install from source"" \"$1\".."
	tar_get "$1"
	case $? in
		0)
			# untar && find PKGBUILD && makepkg
			tar -xf $tartmp 2>/dev/null && \
				cd "$(dirname $(find -type f -name "PKGBUILD" 2> /dev/null|sed 'q'))" && (
					[ ! -z "$EDITOR" ] && ask $"Do you want edit?" rev && (
					eval $(sed '/install=/!d' PKGBUILD)
					$EDITOR PKGBUILD
					[ ! -z $install ] && $EDITOR $install
					)
					makepkg -iscfA $MP_OPTS || makepkgerr+=("$1") # co z błedami?
				)
			tar_del ;;
		1)
			if $pacman -Si $1 > /dev/null 2>&1; then
				msg $"Package not found on aur and community.. Will use other repo.."
				$pacman -S $PAC_OPTS $1
			else
				msg $"Package not found.." "w"
			fi
		;;
		2) msg "Source not found on aur.. Will use community.."; $pacman -S $PAC_OPTS $1
	esac
	tar_del
}
install_deps() {
	msg $"Checking depends for"" \"$1\".."
	# zadeklaruj zmienne lokalne funkcji
	local depends makedepends pkg pacpkgc pacpkg aurpkg aurpkgc
	# przeczytaj zależności
	eval $(curl http://aur.archlinux.org/packages/$1/$1/PKGBUILD 2>/dev/null|sed '
	/optdepends=/d
	/depends=.*)\|makedepends=.*)/!d
	s/$(/no_exec(/g')
	# rozdziel pakiety na takie, które znajdują się w repo i na inne
	for pkg in ${depends[*]} ${makedepends[*]}; do
		# Na wypadek kiczowatej zmiennej w pkgbuildzie, rozbuduj..
		pkg="`echo $pkg|sed 's/\(^.*\)>.*\|\(^.*\)=.*/\1/g; s/=\|>\|<//g'`"
		$pacman -Si $pkg > /dev/null 2>&1 || aurpkgc+=("$pkg")
	done
	# sprawdz czy zainstalowane
	for pkg in ${aurpkgc[*]}; do
		$pacman -Q $pkg > /dev/null 2>&1 || aurpkg+=("$pkg")
	done
	# zainstaluj niezainstalowane
	updates_print ${aurpkg[*]} && \
	ask $"Proceed with installation from aur?" && (
#	(( "${#pacpkg[*]}" > "0" )) && sudo pacman -S --no-confirm ${pacpkg[*]}
	(( "${#aurpkg[*]}" > "0" )) && install_pkg ${aurpkg[*]})
}
install_pkg() {
	if [ "$1" = "--noconfirm" ]; then return 0; fi
	local pkg
	# proces instalacji
	for pkg in $@; do
		if [ "$pkg" != "--noconfirm" ]; then
			mkdir -p "$makedir/$pkg"
			install_deps $pkg
			install_now $pkg
		fi
	done
}
info_print() {
	local c cpkg
	sep
	for cpkg in $@; do
		msg $"Downloading information about"" \"$cpkg\".."
		# json, litości, czy jest jakiś interpretator tego pod basha? ;( json! brzydki kod! json! kurwa!
		if tar_get "$cpkg"; then
			msg $"Done. Prtinting information about"" \"$cpkg\".."
			cat $tartmp|tar -x $(cat $tartmp|tar -t|sed '/PKGBUILD/!d') -O
#		 	|sed '
#			/pkgname=\|pkgver=\|pkgrel=\|pkgdesc=\|arch=\|url=\|license=\|groups=\|provides=\|depends=\|makedepends=\|conflicts=\|replaces=\|backup=\|install=\|source=\|md5sum=s\|packager=/!d
#			s/\(^.*\)=\(.*$\)/\x1b['"$color_linfo"'m\1\x1b['"$color_rinfo"'m\x1b[15G: \2\x1b[0m/g
#			s/()\|\(: $\)/\1/g
#			s/'"('"'//g; s/'"')"'//g; s/'"' '"'/, /g'
		else
			msg $"Package not found.." "w"
		fi
		sep
	done
	tar_del
}
searchinaur() {
	local c
#	pacman_color_integrate $pacman_color_interate_boolean
	# pacman_color_integrate $(echo $pacman|grep -c "pacman-color") # untested..
	msg "Search \"$1\" in aur.."
	c="$(curl 'http://aur.archlinux.org/rpc.php?type=search&arg='"$1" 2>/dev/null)"
	if [ "$(echo $c|grep -c 'type":"error')" = "0" ]; then
		echo $c|sed '
		s/{\|}//g; s/^\("type":""\),"results":\(.*\)/,\1,\2/g
		s/":/=/g; s/,"ID="[0-9]*","/'"\n"'/g
		s/"type="search","results=["ID="[0-9]*","//g'|sort|sed '
		s/\\\//\//g
		s/.*Name="\(.*\)","Version="\(.*\)","Categ.*Description="\(.*\)","LocationID=".*NumVotes="\(.*\)","Out.*"/\x1b['"$color_pcrepo"'maur\x1b[0m\/\x1b[0;'"$color_pcstrong"'m\1 \2 \x1b[0;'"$color_pcgroup"'m('$"votes:"' \4)\n\x1b[0m    \3/g'
	else
		c=$(echo $c|sed 's/.*","results":"\(.*\)"}$/\1/g')
		if [ "$LANGUAGE" = "C" ]; then
			printf "AUR: %s\n" "$c"
		else
			printf "AUR: %s\n" "$c"|sed '
			s/No results found/'$"No results found"'/g
			s/Query arg too small/'$"Query arg too small"'/g'
		fi
	fi
}
searchinrepo() {
	msg "Search \"$1\" in repo.."
	$pacman -Ss $1
}
#update() {
##	 sprawdzanie wersji
#	msg $"Synchronizing package databases..."
#	local pacqm=($($pacman -Qm|cut -d\  -f1)) bars=""
#	local -i bari=0 n=0 margin=6
#	printf "\e[0;%sm" "$color_progress"
#	for pkg in ${!pacqm[*]}; do
#		bars=""; n=0
#		proc=$[pkg*100/$[${#pacqm[*]}-1]]
#		bari=$[pkg*$[cols-margin]/$[${#pacqm[*]}-1]]
#		until ((n++, n > bari )); do bars+="${style_progress:0:1}"; done
#		printf "\r [%s\e[$[cols-margin]G] %4s" "$bars" "$proc%"
#		check_ver ${pacqm[$pkg]} || upkg+=("${pacqm[$pkg]}")
#	done
#	printf "\e[0m\n"
##	 aktualizacja staruszków
#	msg $"Starting full system upgrade..."
#	if (( "${#upkg[*]}" > 0 )); then
#		updates_print ${upkg[*]}
#		ask $"Proceed with installation?" \
#			&& install_pkg ${upkg[*]}
#	else
#		printf " %s\n" $"local database is up to date"
#	fi
#}
update() {
	[ "$AUR_ONLY" != "1" ] && $pacman -Sy
	local pacqm=($($pacman -Qm|cut -d\  -f1)) bars="" bname="aur"
	local -i bari=0 n=0 margin=6
#	printf "\e[0;%sm" "$color_progress"
	for pkg in ${!pacqm[*]}; do
		bars=""; n=0
		proc=$[pkg*100/$[${#pacqm[*]}-1]]
		bari=$[pkg*$[cols-margin-${#bname}]/$[${#pacqm[*]}-1]]
#		until ((n++, n > bari )); do bars+="${style_progress:0:1}"; done
		SEP="$(printf "%*s" "$bari")"
		bars="$(printf '%s' "${SEP// /#}")"
		printf "\r %s [%s\e[$[cols-margin]G] %4s" "$bname" "$bars" "$proc%"
		upkg+="$(check_ver ${pacqm[$pkg]})"
	done
	printf "\n"
	echo "$upkg" > $HOME/.aurpac.upgradedb
}
stripdb() {
	sed 's/$(/(/g; s/`/"/g; s/ /\n/g' $HOME/.aurpac.upgradedb
}
get_pacman_updates() {
  PAC_OUTPUT=$(pacman -Qu | tac | tail -n+3 | grep -v '^ *$' | sed 's/^.\+ ([0-9]\+): \(.\+\)$/\1\nDONE/' | sed 's/\[[^]]*\]//g')
  [ -z "$(echo -e "$PAC_OUTPUT" | grep '^DONE$')" ] && return
  while read LINE
  do
    if [ "$LINE" == "DONE" ]
    then
      break
    fi
    for PKG in $LINE
    do
      echo $PKG
    done
  done << OUTPUT
$PAC_OUTPUT
OUTPUT
}
upgrade() {
	local p_updates a_updates i
	printf "%s\n" $"Checking for package upgrades..."
	[ "$AUR_ONLY" != "1" ] &&p_updates="$(get_pacman_updates)"
	a_updates="$(stripdb)"
	updates_print $p_updates $a_updates
	if ask $"Proceed with installation?"; then
		[ ! -z "$p_updates" -a "$AUR_ONLY" != "1" ] && $pacman -Su --noconfirm
		for i in $a_updates; do
			install_pkg $(echo $i|sed 's/\(.*\)-[0-9.a-zA-Z]*-[0-9.a-zA-Z]*$/\1/g') \
				&& sed -i 's/'"$i"' //g' $HOME/.aurpac.upgradedb
		done
	fi
}
setswitch() {
	if [ "${1:0:2}" = "-:" ]; then
		opt=${1:2}
		opt=${opt/,/ }
	else
		opt=${1/!/no}
	fi
	for i in $opt; do
		case i in
			noconfirm|nc) NOCONFIRM=1;;
			confirm|c) NOCONFIRM=0;;
		esac
	done
}
phelp() {
	local v="0.1 beta 2"
	case $1 in
		"main")
			echo $"usage: %n <operation> [...]
operations:
  %n -Sh ........Sync help
  %n -Rh ........Remove help
  %n -Qh ........Query help
  %n -Uh ........Upgrade help

aurpac version %v (C) 3ED 2009
  This program comes  with ABSOLUTELY NO WARRANTY;
  This program may be freely  redistributed  under
  the terms of the GNU GPL 3. For more information
  read:   http://www.gnu.org/licenses/gpl-3.0.html"
		;;
		"sync")
			echo $"usage: %n <options> [package]
options:
  %n -S   .......Install package from aur
  %n -Ss  .......Search package in aur
  %n -Ssp .......Search package in aur and pacman
  %n -Si  .......Print information about package
  %n -Su  .......System upgrade, please"
		;;
	esac|sed 's/%n/'"$(basename $0)"'/g; s/%v/'"$v"'/g'
}

mod_load "post"
#mod_load "mod" ${modules[*]}

#setswitch = "${DEFAULT_SWITCH[*]}"

#if [ "$(echo $@|grep -c "\-\-noconfirm")" -ge "1" ]; then
#	unset EDITOR
#	MP_OPTS+="--noconfirm "
#	PAC_OPTS+="--noconfirm "
#	NOCONFIRM="1"
#fi
#
#if [ -z "$1" ]; then
#	phelp main
#	exit 0
#fi
#
#opt=$1; shift
#
#case $opt in
#	"-Su"|"-Sy"|"-Suy"|"-Syu") update ;;
#	"-S")	install_pkg $@ ;;
#	"-Si") info_print $@ ;;
#	"-Ss") search $1 ;;
#	"-Ssp") $pacman -Ss $1; search $1 ;;
#	"-Sh") phelp sync ;;
#	"-h"|"--help") phelp main ;;
#	*)
#		if [ "${opt:0:2}" == "-R" ]; then
#			if [ "${opt}" == "-Rh" ]; then
#				$pacman $opt|sed 's/ pacman-color\| pacman/'"$(basename $0)"'/g; s/{-R --remove}/{-R}/g'
#			else
#				$pacman $opt $@
#			fi
#		elif [ "${opt:0:2}" == "-Q" ]; then
#			if [ "${opt}" == "-Qh" ]; then
#				$pacman $opt|sed 's/ pacman-color\| pacman/'"$(basename $0)"'/g; s/{-Q --query}/{-Q}/g'
#			else
#				$pacman $opt $@
#			fi
#		elif [ "${opt:0:2}" == "-U" ]; then
#			if [ "${opt}" == "-Uh" ]; then
#				$pacman $opt|sed 's/ pacman-color\| pacman/'"$(basename $0)"'/g; s/{-U --upgrade}/{-U}/g'
#			else
#				$pacman $opt $@
#			fi
#		else
#			printf "%s \e[34;1m$(basename $0) --help\e[0m\n" $"Unknown option, try:"
#		fi
#esac

#HELP must be firt option..
case $1 in
	"-Sh") phelp sync; exit 1;;
	"-h"|"--help") phelp main; exit 1;;
	"-RH"|"-Qh"|"-Uh")
		case $1 in
			"-Rh")
				$pacman $1|sed 's/ pacman-color\| pacman/'"$(basename $0)"'/g; s/{-R --remove}/{-R}/g'
			;;
			"-Qh")
				$pacman $opt|sed 's/ pacman-color\| pacman/'"$(basename $0)"'/g; s/{-Q --query}/{-Q}/g'
			;;
			"-Uh")
				$pacman $opt|sed 's/ pacman-color\| pacman/'"$(basename $0)"'/g; s/{-U --upgrade}/{-U}/g'
			;;
		esac
		exit 1
	;;
esac

#Getopts for aurpac..
typeset -i antiloop=0
until [ -z "$1" ] || (( antiloop++, $antiloop >= 500 )); do
	case $1 in
		-:*) setswitch "$1"; shift;;
		"--noconfirm")
			#setswitch noconfirm
			shift
			NOCONFIRM="1"
			case $1 in
				true) shift;;
				false) NOCONFIRM="0"; shift;;
			esac
		;;
		"-Sy") shift; if [ "$1" = "--aur" ]; then AUR_ONLY="1"; shift; fi; update;;
		"-Su") shift; if [ "$1" = "--aur" ]; then AUR_ONLY="1"; shift; fi; upgrade;;
		"-Suy"|"-Syu") shift; if [ "$1" = "--aur" ]; then AUR_ONLY="1"; shift; fi; update; upgrade;;
		"-Ss") shift; searchinrepo $1; searchinaur $1; shift;;
		"-Ssa") shift; searchinaur $1; shift;;
		"-Ssp") shift; searchinrepo $1; shift;;
		*)
			case ${1:0:1} in
				"-")
					opt="$1"
					unset param
					shift
					until [ "${1:0:1}" = "-" ]; do
						if [ -z "$1" ]; then break; fi
						param+="$1 "
						shift
					done
					case $opt in
						-S)	install_pkg $param;;
						-R*|-Q*|-U*) $pacman $opt $param;;
						-Si) info_print $param;;
					esac
				;;
				"")
					break
				;;
			esac
		;;
	esac
done


if [ ! -z "${makepkgerr[*]}" ]; then
	msg $"Compile with error:"" ${makepkgerr[*]}" "w"
	exit 1
fi
exit 0
